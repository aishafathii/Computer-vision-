# -*- coding: utf-8 -*-
"""Untitled8.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nDK8VpZ8GxauGtRYcyfW_uoNHubwefI3
"""

import keras
import numpy as np
from google.colab import files
import json
from sklearn import svm
from sklearn.metrics import classification_report,accuracy_score
import zipfile

files.upload()
!mkdir -p  ~/.kaggle
!cp kaggle.json ~/.kaggle
!chmod 600 ~/.kaggle/kaggle.json
!kaggle competitions download -c digit-recognizer

local_zip = 'train.csv.zip'
zip_ref = zipfile.ZipFile(local_zip, 'r')
zip_ref.extractall('/train/')
zip_ref.close()

import pandas as pd
train = pd.read_csv("/train/train.csv")
print(train.shape)


Y = train["label"]
X = train.drop(labels=["label"],axis=1)

print("y_train shape:",Y.shape)
print("x_train shape:",X.shape)

from sklearn.model_selection import train_test_split
x_train, x_test, y_train, y_test = train_test_split(X, Y, test_size = 0.1, random_state = 14)
print(x_train.shape)
print(y_train.shape)
print(x_test.shape)
print(y_test.shape)


import matplotlib.pyplot as plt
from skimage.transform import resize
import math
from scipy import ndimage
from skimage import data, exposure
image = data.astronaut()
from skimage import color
from skimage import io

def HoG(image):
  
  #image = color.rgb2gray(image)
  #resized_img = color.rgb2gray(resized_img)
  def cells_histo(cell_magnitude,cell_phase,bins):
    hist_all_cells = []
    for y in range(0, 128, 8):
        for x in range(0, 64, 8):
            cell_phase = phase[y:y+8, x:x+8]
            cell_magnitude = Magnitude[y:y+8, x:x+8]
            cell_hist = cell_histogram(cell_magnitude, cell_phase, bins)
            hist_all_cells.append(cell_hist)
    #print((cell_phase.shape))
    return hist_all_cells

  def cell_histogram(cell_magnitude, cell_phase, bins):
    cell_hist = np.zeros(len(bins))
    cell_size = cell_phase.shape[0]
    for row_idx in range(cell_size):
        for col_idx in range(cell_size):
            curr_direction = cell_phase[row_idx, col_idx]
            curr_magnitude = cell_magnitude[row_idx, col_idx]

            diff = np.abs(curr_direction - bins)

            # find interested the 2 bins
            if curr_direction <= bins[0]:
                first_bin = 0
                second_bin = len(bins) - 1
            elif curr_direction > bins[-1]:
                first_bin = len(bins) - 1
                second_bin = 0
            else:
                first_bin = np.where(diff == np.min(diff))[0][0]
                temp1 = bins[(first_bin - 1) % len(bins)]
                temp2 = bins[(first_bin + 1) % len(bins)]
                before_first = np.abs(curr_direction - temp1)
                after_first = np.abs(curr_direction - temp2)
                if(before_first < after_first):
                    second_bin = first_bin - 1
                else:
                    second_bin = first_bin + 1

            BIN_1 = bins[first_bin]
            BIN_2 = bins[second_bin]
            #print(BIN_1)
            #print(BIN_2)
            # the distribution of magnitude
            cell_hist[second_bin] += (np.abs(curr_direction - BIN_1))/ (180.0 / bins.size) * curr_magnitude
            cell_hist[first_bin] += (np.abs(curr_direction - BIN_2))/ (180.0 / bins.size) * curr_magnitude
    return cell_hist



  def visualize_histogram_all_cells(hist_all_cells, hist_bin):
     for i in range(128):
        plt.bar(hist_bin, hist_all_cells[i], align="center", width=15)
        plt.show()

    # Normalization
  def normalization(hist_cells):
    normalized_blocks = []
    hist_cells = np.array(hist_cells)
    histo_cells = hist_cells.reshape(1152)
    for y in range(0, 1152, 36):
      block = histo_cells[y:y+36]
      normalized_block = norm(block)
      normalized_blocks.append(normalized_block)
    return normalized_blocks

  def norm(vector_of_block):
    norm = np.sum(vector_of_block)
    normalization = vector_of_block / norm
    return normalization

  # Get x-gradient 
  Gx = ndimage.sobel(resized_img,axis=0,mode='constant')
  # Get y-gradient 
  Gy = ndimage.sobel(resized_img,axis=1,mode='constant')
  # Get the magnitude
  Magnitude = np.hypot(Gx,Gy)
  phase = np.arctan2(Gx, Gy) * (180 / np.pi) % 180    # There is no theta greater than 180 degree
  # plt.imshow(Magnitude)
  # plt.show()
  #print(phase)
    
  bins = np.array([0, 20, 40, 60, 80, 100, 120, 140, 160])
  histogram_cells = cells_histo(Magnitude, phase, bins)
  #visualize_histogram_all_cells(histogram_cells, bins)

  normalizations_all_blocks = normalization(histogram_cells)
  return(normalizations_all_blocks)
  #print(normalizations_all_blocks)



i=0
hog_features = np.zeros((1000,1152))
Y_train = np.zeros((1000))
X_train = np.zeros((1000))
Y_train = y_train[0:1000]
X_train = x_train[0:1000]
print(X_train.shape)
while i < 1000:
  img = X_train.to_numpy()[i].reshape(28,28)
  resized_img = resize(img, (128, 64))
  """plt.imshow(resized_img)
  plt.title(str(y_train[i]))
  plt.colorbar()
  plt.show()"""
  arr = np.concatenate(HoG (resized_img), axis=0)
  hog_features[i] = arr
  #plt.imshow(hog_feature)
  i = i + 1

local_zip = 'test.csv.zip'
zip_ref = zipfile.ZipFile(local_zip, 'r')
zip_ref.extractall('/test/')
zip_ref.close()

from sklearn.svm import SVC

svclassifier = SVC(kernel='linear')
svclassifier.fit(hog_features, Y_train)

#test = pd.read_csv("/test/test.csv")
#print(test.shape)

i=0
hog_feature_test = np.zeros((100,1152))
Y_test = np.zeros((100))
X_test = np.zeros((100))
Y_test = y_test[0:100]
X_test = x_test[0:100]
while i < 100:
  img = X_test.to_numpy()[i].reshape(28,28)
  resized_img = resize(img, (128, 64))
  #plt.imshow(resized_img)
  #plt.show()
  #print(HoG (resized_img))
  arr2 = np.concatenate(HoG (resized_img), axis=0)
  hog_feature_test[i] = arr2
  #print(hog_feature_test)
  i = i + 1
y_pred = svclassifier.predict(hog_feature_test)
#print(y_pred)
from sklearn.metrics import accuracy_score
Accuracy = accuracy_score(Y_test, y_pred)
print('Accuracy is : ', Accuracy)

import matplotlib.pyplot as plt
from skimage.transform import resize
import math
from scipy import ndimage
from skimage import data, exposure
image = data.astronaut()
from skimage import color
from skimage import io

def HoG(image):
  
  #image = color.rgb2gray(image)
  #resized_img = color.rgb2gray(resized_img)
  def cells_histo(cell_magnitude,cell_phase,bins):
    hist_all_cells = []
    for y in range(0, 128, 8):
        for x in range(0, 64, 8):
            cell_phase = phase[y:y+8, x:x+8]
            cell_magnitude = Magnitude[y:y+8, x:x+8]
            cell_hist = cell_histogram(cell_magnitude, cell_phase, bins)
            hist_all_cells.append(cell_hist)
    #print((cell_phase.shape))
    return hist_all_cells

  def cell_histogram(cell_magnitude, cell_phase, bins):
    cell_hist = np.zeros(len(bins))
    cell_size = cell_phase.shape[0]
    for row_idx in range(cell_size):
        for col_idx in range(cell_size):
            curr_direction = cell_phase[row_idx, col_idx]
            curr_magnitude = cell_magnitude[row_idx, col_idx]

            diff = np.abs(curr_direction - bins)

            # find interested the 2 bins
            if curr_direction <= bins[0]:
                first_bin = 0
                second_bin = len(bins) - 1
            elif curr_direction > bins[-1]:
                first_bin = len(bins) - 1
                second_bin = 0
            else:
                first_bin = np.where(diff == np.min(diff))[0][0]
                temp1 = bins[(first_bin - 1) % len(bins)]
                temp2 = bins[(first_bin + 1) % len(bins)]
                before_first = np.abs(curr_direction - temp1)
                after_first = np.abs(curr_direction - temp2)
                if(before_first < after_first):
                    second_bin = first_bin - 1
                else:
                    second_bin = first_bin + 1

            BIN_1 = bins[first_bin]
            BIN_2 = bins[second_bin]
            #print(BIN_1)
            #print(BIN_2)
            # the distribution of magnitude
            cell_hist[second_bin] += (np.abs(curr_direction - BIN_1))/ (180.0 / bins.size) * curr_magnitude
            cell_hist[first_bin] += (np.abs(curr_direction - BIN_2))/ (180.0 / bins.size) * curr_magnitude
    return cell_hist



  def visualize_histogram_all_cells(hist_all_cells, hist_bin):
     for i in range(128):
        plt.bar(hist_bin, hist_all_cells[i], align="center", width=15)
        plt.show()

    # Normalization
  def normalization(hist_cells):
    normalized_blocks = []
    hist_cells = np.array(hist_cells)
    histo_cells = hist_cells.reshape(1152)
    for y in range(0, 1152, 36):
      block = histo_cells[y:y+36]
      normalized_block = norm(block)
      normalized_blocks.append(normalized_block)
    return normalized_blocks

  def norm(vector_of_block):
    norm = np.sum(vector_of_block)
    normalization = vector_of_block / norm
    return normalization

  # Get x-gradient 
  Gx = ndimage.sobel(resized_img,axis=0,mode='constant')
  # Get y-gradient 
  Gy = ndimage.sobel(resized_img,axis=1,mode='constant')
  # Get the magnitude
  Magnitude = np.hypot(Gx,Gy)
  phase = np.arctan2(Gx, Gy) * (180 / np.pi) % 180    # There is no theta greater than 180 degree
  # plt.imshow(Magnitude)
  # plt.show()
  #print(phase)
    
  bins = np.array([0, 20, 40, 60, 80, 100, 120, 140, 160])
  histogram_cells = cells_histo(Magnitude, phase, bins)
  #visualize_histogram_all_cells(histogram_cells, bins)

  normalizations_all_blocks = normalization(histogram_cells)
  return(normalizations_all_blocks)
  #print(normalizations_all_blocks)



i=0
hog_features = np.zeros((1000,1152))
Y_train = np.zeros((1000))
X_train = np.zeros((1000))
Y_train = y_train[0:1000]
X_train = x_train[0:1000]
print(X_train.shape)
while i < 1000:
  img = X_train.to_numpy()[i].reshape(28,28)
  resized_img = resize(img, (128, 64))
  """plt.imshow(resized_img)
  plt.title(str(y_train[i]))
  plt.colorbar()
  plt.show()"""
  arr = np.concatenate(HoG (resized_img), axis=0)
  hog_features[i] = arr
  #plt.imshow(hog_feature)
  i = i + 1

local_zip = 'test.csv.zip'
zip_ref = zipfile.ZipFile(local_zip, 'r')
zip_ref.extractall('/test/')
zip_ref.close()

from sklearn.svm import SVC

svclassifier = SVC(kernel='linear')
svclassifier.fit(hog_features, Y_train)

#test = pd.read_csv("/test/test.csv")
#print(test.shape)

i=0
hog_feature_test = np.zeros((100,1152))
Y_test = np.zeros((100))
X_test = np.zeros((100))
Y_test = y_test[0:100]
X_test = x_test[0:100]
while i < 100:
  img = X_test.to_numpy()[i].reshape(28,28)
  resized_img = resize(img, (128, 64))
  #plt.imshow(resized_img)
  #plt.show()
  #print(HoG (resized_img))
  arr2 = np.concatenate(HoG (resized_img), axis=0)
  hog_feature_test[i] = arr2
  #print(hog_feature_test)
  i = i + 1
y_pred = svclassifier.predict(hog_feature_test)
#print(y_pred)
from sklearn.metrics import accuracy_score
Accuracy = accuracy_score(Y_test, y_pred)
print('Accuracy is : ', Accuracy)

while i < 100:
  img = X_test.to_numpy()[i].reshape(28,28)
  resized_img = resize(img, (128, 64))
  #plt.imshow(resized_img)
  #plt.show()
  #print(HoG (resized_img))
  arr2 = np.concatenate(HoG (resized_img), axis=0)
  hog_feature_test[i] = arr2
  #print(hog_feature_test)
  i = i + 1
y_pred = svclassifier.predict(hog_feature_test)
print('predicted y : ',y_pred)
print('\n')
print('True y:\n',Y_test)
from sklearn.metrics import accuracy_score
Accuracy = accuracy_score(Y_test, y_pred)
print('Accuracy is : ', Accuracy)